import { CustomMesages, InitialRules, CustomAttributes } from './types';
import ErrorBag from './validators/errorBag';
declare class Validator {
    /**
     * The lang used to return error messages
     */
    private lang;
    /**
     * The data object that will be validated
     */
    private data;
    /**
     * The rules that will be used to check the validity of the data
     */
    private rules;
    /**
     * This is an unchanged version of the inital rules before being changed for wildcard validations
     */
    private initalRules;
    /**
     * The array of wildcard attributes with their asterisks expanded.
     */
    private implicitAttributes;
    /**
     * Hold the error messages
     */
    private messages;
    /**
     * Stores an instance of the validateAttributes class
     */
    private validateAttributes;
    /**
     * Flag that defines wether or not validation should stop on first failure
     */
    private stopOnFirstFailureFlag;
    /**
     * Custom mesages returrned based on the error
     */
    customMessages: CustomMesages;
    /**
     * Object of custom attribute name;
     */
    customAttributes: CustomAttributes;
    constructor(data: object, rules: InitialRules, customMessages?: CustomMesages, customAttributes?: CustomAttributes);
    setData(data: object): Validator;
    setRules(rules: InitialRules): Validator;
    setLang(lang: string): Validator;
    getLang(): string;
    setCustomMessages(customMessages?: CustomMesages): Validator;
    setCustomAttributes(customAttributes?: CustomAttributes): Validator;
    stopOnFirstFailure(stopOnFirstFailure?: boolean): Validator;
    errors(): ErrorBag;
    /**
     * Run the validator's rules against its data.
     */
    validate(key?: string, value?: any): boolean;
    /**
     * Get the displayable name of the attribute.
     */
    getDisplayableAttribute(attribute: string): string;
    /**
     * Replace all error message place-holders with actual values.
     */
    private makeReplacements;
    /**
     * Loop through all rules and run validation against each one of them
     */
    private runAllValidations;
    /**
     * Run validation for one specific attribute
     */
    private runSingleValidation;
    /**
     * Run validation rules for the specified property and stop validation if needed
     */
    private runValidation;
    /**
     * Check if we should stop further validations on a given attribute.
     */
    private shouldStopValidating;
    /**
     * Parse the given rules add assign them to the current rules
     */
    private addRules;
    /**
     * validate a given attribute against a rule.
     */
    private validateAttribute;
    /**
     * Validate an attribute using a custom rule object
     */
    private validateUsingCustomRule;
    /**
     * Add a new error message to the messages object
     */
    private addFailure;
    /**
     * Replace each field parameter which has asterisks with the given keys.
     *
     * Example: parameters = [name.*.first] and keys = [1], then the result will be name.1.first
     */
    private replaceAsterisksInParameters;
    /**
     * Determine if the attribute is validatable.
     */
    private isValidatable;
    /**
     * Determine if the field is present, or the rule implies required.
     */
    private presentOrRuleIsImplicit;
    /**
     * Determine if the attribute passes any optional check.
     */
    private passesOptionalCheck;
    /**
     * Determine if the attribute fails the nullable check.
     */
    private isNotNullIfMarkedAsNullable;
    /**
     * Get the primary attribute name
     *
     * Example:  if "name.0" is given, "name.*" will be returned
     */
    private getPrimaryAttribute;
    /**
     * Get the explicit keys from an attribute flattened with dot notation.
     *
     * Example: 'foo.1.bar.spark.baz' -> [1, 'spark'] for 'foo.*.bar.*.baz'
     */
    private getExplicitKeys;
}
export default Validator;
