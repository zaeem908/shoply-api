'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const validator_1 = __importDefault(require("../validator"));
const ruleContract_1 = __importDefault(require("./ruleContract"));
class Password extends ruleContract_1.default {
    constructor() {
        super(...arguments);
        /**
         * The minimum size of the password.
         */
        this.minLength = 8;
        /**
         * The min amount of lower case letters required in the password
         */
        this.minLowerCase = 0;
        /**
         * The min amount of uppercase letters required in the password
         */
        this.minUpperCase = 0;
        /**
         * The min amount of letters required in the password
         */
        this.minLetters = 0;
        /**
         * The min amount of letters required in the password
         */
        this.minNumbers = 0;
        /**
         * The min amount of symbols required in the password
         */
        this.minSymbols = 0;
        /**
         * Additional validation rules that should be merged into the default rules during validation.
         */
        this.customRules = [];
    }
    /**
     * Create a new instance of the password class
     */
    static create() {
        return new Password();
    }
    /**
     * Set the minimum length of the password
     */
    min(min) {
        this.minLength = min;
        return this;
    }
    /**
     * Set the min amount of letters required in the password
     */
    letters(letters = 1) {
        this.minLetters = letters;
        return this;
    }
    /**
     * Set the min amount of upper and lower case letters required in the password
     */
    mixedCase(upperCase = 1, lowerCase = 1) {
        this.minUpperCase = upperCase;
        this.minLowerCase = lowerCase;
        return this;
    }
    /**
     * Set the min amount of numbers required in the password
     */
    numbers(numbers = 1) {
        this.minNumbers = numbers;
        return this;
    }
    ;
    /**
     * Set the min amount of symbols required in the password
     */
    symbols(symbols = 1) {
        this.minSymbols = symbols;
        return this;
    }
    /**
     * Determine if the validation rule passes.
     */
    passes(value, attribute) {
        const validator = new validator_1.default(this.data, {
            [attribute]: ['string', `min:${this.minLength}`, ...this.customRules]
        }, this.validator.customMessages, this.validator.customAttributes).setLang(this.lang);
        if (!validator.validate()) {
            const errors = validator.errors().addErrorTypes().get(attribute);
            for (let key in errors) {
                this.validator.errors().add(attribute, errors[key]);
            }
        }
        if (typeof value !== 'string') {
            value = '';
        }
        let pattern;
        const formattedAttribute = this.validator.getDisplayableAttribute(attribute);
        if (this.minLowerCase) {
            pattern = this.minLowerCase === 1 ? /\p{Ll}/u : new RegExp(`(.*\\p{Ll}){${this.minLowerCase}}.*`, 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_lower_case',
                    message: this.trans(`password.${this.minLowerCase === 1 ? 'lower_case' : 'lower_cases'}`, {
                        attribute: formattedAttribute, amount: this.minLowerCase
                    })
                });
            }
        }
        if (this.minUpperCase) {
            pattern = this.minUpperCase === 1 ? /\p{Lu}/u : new RegExp(`(.*\\p{Lu}){${this.minUpperCase}}.*`, 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_upper_case',
                    message: this.trans(`password.${this.minUpperCase === 1 ? 'upper_case' : 'upper_cases'}`, {
                        attribute: formattedAttribute, amount: this.minUpperCase
                    })
                });
            }
        }
        if (this.minLetters) {
            pattern = this.minLetters === 1 ? /\p{L}/u : new RegExp(`(.*\\p{L}){${this.minLetters}}.*`, 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_letters',
                    message: this.trans(`password.${this.minLetters === 1 ? 'letter' : 'letters'}`, {
                        attribute: formattedAttribute, amount: this.minLetters
                    })
                });
            }
        }
        if (this.minNumbers) {
            pattern = this.minNumbers === 1 ? /\p{N}/u : new RegExp(`(.*\\p{N}){${this.minNumbers}}.*`, 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_numbers',
                    message: this.trans(`password.${this.minNumbers === 1 ? 'number' : 'numbers'}`, {
                        attribute: formattedAttribute, amount: this.minNumbers
                    })
                });
            }
        }
        if (this.minSymbols) {
            pattern = this.minSymbols === 1 ? /\p{Z}|\p{S}|\p{P}/u : new RegExp(`(.*(\\p{Z}|\\p{S}|\\p{P})){${this.minSymbols}}.*`, 'u');
            if (!value || pattern.test(value) === false) {
                this.validator.errors().add(attribute, {
                    error_type: 'min_symbols',
                    message: this.trans(`password.${this.minSymbols === 1 ? 'symbol' : 'symbols'}`, {
                        attribute: formattedAttribute, amount: this.minSymbols
                    })
                });
            }
        }
        if (this.validator.errors().has(attribute)) {
            return false;
        }
        return true;
    }
    /**
     * Specify additional validation rules that should be merged with the default rules during validation.
     */
    rules(rules) {
        this.customRules = rules;
        return this;
    }
    /**
     * Get all the validation error messages related to the password
     */
    getMessage() {
        return {};
    }
    /**
     * Set the validator instance used to validate the password
     */
    setValidator(validator) {
        this.validator = validator;
        return this;
    }
    /**
     * Set the default callback to be used for determining a password's default rules.
     */
    static setDefault(callback = null) {
        if (callback instanceof Password) {
            this.defaultCallback = callback;
            return;
        }
        if (typeof callback !== 'function') {
            throw 'The given callback should be callable';
        }
        this.defaultCallback = callback;
    }
    /**
     * Get the default configuration of the password rule.
     */
    static default() {
        const password = typeof this.defaultCallback === 'function' ? this.defaultCallback() : this.defaultCallback;
        return password instanceof ruleContract_1.default ? password : Password.create().min(8);
    }
}
;
exports.default = Password;
