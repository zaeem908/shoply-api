'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compare = exports.isNumericRule = exports.getNumericRules = exports.addImplicitRule = exports.isImplicitRule = exports.isSizeRule = exports.isArrayOfRules = exports.isRule = exports.isInteger = exports.sameType = exports.getSize = void 0;
const ruleContract_1 = __importDefault(require("../rules/ruleContract"));
const baseRule_1 = __importDefault(require("../rules/baseRule"));
const implicitRuleContract_1 = __importDefault(require("../rules/implicitRuleContract"));
const implicitRues = [
    'accepted', 'accepted_if', 'declined', 'declined_if',
    'filled', 'present', 'required', 'required_if', 'required_unless',
    'required_with', 'required_with_all', 'required_without', 'required_without_all'
];
/**
 * Get the size of a value based on its type
 */
function getSize(value, hasNumericRule = false) {
    if (typeof value === 'number' || (isNaN(value) === false && hasNumericRule === true)) {
        return Number(value);
    }
    else if (typeof value === 'string' || Array.isArray(value)) {
        return value.length;
    }
    else if (typeof value === 'object' && value !== null) {
        return Object.keys(value).length;
    }
    return -1;
}
exports.getSize = getSize;
;
/**
 * Check if two values are of the same type
 */
function sameType(value, otherValue) {
    const valueType = Array.isArray(value) ? 'array' : typeof value;
    const otherValueType = Array.isArray(otherValue) ? 'array' : typeof otherValue;
    return valueType === otherValueType;
}
exports.sameType = sameType;
;
/**
 * Check if Value is an Ineteger
 */
function isInteger(value) {
    return value !== null && isNaN(value) === false && value % 1 === 0;
}
exports.isInteger = isInteger;
;
/**
 * Check if the value can be considered as rule
 */
function isRule(value) {
    return typeof value === 'string' ||
        typeof value === 'function' ||
        value instanceof ruleContract_1.default ||
        value instanceof baseRule_1.default;
}
exports.isRule = isRule;
;
/**
 * Check if the array contain any potentiel valid rule
 */
function isArrayOfRules(values) {
    for (let i = 0; i < values.length; i++) {
        if (isRule(values[i])) {
            return true;
        }
    }
    return false;
}
exports.isArrayOfRules = isArrayOfRules;
/**
 * Check if the rule is related to size
 */
function isSizeRule(rule) {
    const sizeRules = [
        'size', 'between', 'min', 'max', 'gt', 'lt', 'gte', 'lte'
    ];
    return sizeRules.indexOf(rule) !== -1;
}
exports.isSizeRule = isSizeRule;
;
/**
 * Check if rule implies that the field is required
 */
function isImplicitRule(rule) {
    if (rule instanceof implicitRuleContract_1.default) {
        return true;
    }
    if (typeof rule === 'string') {
        return implicitRues.indexOf(rule) !== -1;
    }
    return false;
}
exports.isImplicitRule = isImplicitRule;
;
/**
 * Add a new implicit rule
 */
function addImplicitRule(rule) {
    implicitRues.push(rule);
}
exports.addImplicitRule = addImplicitRule;
/**
 * Returns the numeric rules
 */
function getNumericRules() {
    return ['numeric', 'integer'];
}
exports.getNumericRules = getNumericRules;
;
/**
 * Check if the rule is numeric
 */
function isNumericRule(rule) {
    const numericRules = getNumericRules();
    return numericRules.indexOf(rule) !== -1;
}
exports.isNumericRule = isNumericRule;
;
/**
 * Determine if a comparison passes between the given values.
 */
function compare(first, second, operator, strict = false) {
    switch (operator) {
        case '<':
            return first < second;
        case '>':
            return first > second;
        case '<=':
            return first <= second;
        case '>=':
            return first >= second;
        case '=':
            if (strict === true) {
                return first === second;
            }
            return first == second;
        default:
            throw 'Invalid operator parameter';
    }
}
exports.compare = compare;
